from django.shortcuts import render, get_object_or_404, redirect
from django.db.models import Count, Q, F, Prefetch, Exists, OuterRef, Subquery
from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger
from django.views.generic import ListView, TemplateView
from django.utils import timezone
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.urls import resolve

from .models import Movie, Genre, Rating, Season, Episode
from profiles.models import WatchHistory, MyList

def get_ai_content_counts():
    """Helper function to get counts for AI content categories."""
    return {
        'ai_generated_count': Movie.objects.filter(
            content_category='ai_generated',
            is_active=True
        ).count(),
        'ai_upscaled_count': Movie.objects.filter(
            content_category='ai_upscaled',
            is_active=True
        ).count(),
        'user_created_count': Movie.objects.filter(
            content_category='user_created',
            is_active=True
        ).count(),
        'ai_series_count': Movie.objects.filter(
            content_category='ai_series',
            is_active=True
        ).count(),
    }

def get_ai_content_by_category(category_slug, limit=8, user=None):
    """Helper function to get content by AI category slug."""
    category_map = {
        'ai-generated': 'ai_generated',
        'ai-upscaled': 'ai_upscaled',
        'user-created': 'user_created',
        'ai-series': 'ai_series',
    }
    
    content_category = category_map.get(category_slug, 'ai_generated')
    
    # Base queryset
    queryset = Movie.objects.filter(
        content_category=content_category,
        is_active=True
    )
    
    # Add user-specific annotations if user is authenticated
    if user and user.is_authenticated:
        # Check if content is in user's watch history
        queryset = queryset.annotate(
            in_watchlist=Count('mylist', filter=Q(mylist__user=user)),
            watch_progress=Count('watchhistory', filter=Q(watchhistory__user=user)),
        )
    
    # Order by release date and limit results
    return queryset.order_by('-release_date')[:limit]


def get_category_display_name(category_slug):
    """Get the display name for a category slug."""
    category_names = {
        'ai-generated': 'AI-Generated Movies',
        'ai-upscaled': 'AI-Upscaled Classics',
        'user-created': 'User Creations',
        'ai-series': 'AI-Generated Series',
    }
    return category_names.get(category_slug, 'AI Content')


def get_category_description(category_slug):
    """Get the description for a category slug."""
    descriptions = {
        'ai-generated': 'Movies entirely generated by AI, featuring unique stories and characters created by machine learning algorithms.',
        'ai-upscaled': 'Classic films enhanced with AI upscaling technology for modern viewing experiences.',
        'user-created': 'Content created by our community using AI tools and shared on our platform.',
        'ai-series': 'Binge-worthy series generated by AI, with consistent characters and evolving storylines.',
    }
    return descriptions.get(category_slug, 'Explore our collection of AI-generated content.')


class AIHomeView(TemplateView):
    """View for the AI content home page."""
    template_name = 'movies/ai_home.html'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        
        # Get AI content counts
        context.update(get_ai_content_counts())
        
        # Get sample content from each category
        context['ai_generated'] = get_ai_content_by_category('ai-generated', 8)
        context['ai_upscaled'] = get_ai_content_by_category('ai-upscaled', 8)
        context['user_creations'] = get_ai_content_by_category('user-created', 8)
        context['ai_series'] = get_ai_content_by_category('ai-series', 8)
        
        # Get trending AI content (ordered by newest first)
        context['trending_ai'] = Movie.objects.filter(
            is_trending=True,
            is_active=True
        ).order_by('-release_date')[:10]
        
        return context


class AICategoryView(ListView):
    """View for browsing AI content by category."""
    model = Movie
    template_name = 'movies/ai_category.html'
    context_object_name = 'items'
    paginate_by = 20
    
    def get_queryset(self):
        # Get the category slug from the URL pattern
        self.category_slug = self.kwargs.get('category_slug')
        
        # Map URL names to slugs for the category view
        url_name_mapping = {
            'ai_generated': 'ai-generated',
            'ai_upscaled': 'ai-upscaled',
            'user_created': 'user-created',
            'ai_series': 'ai-series',
        }
        
        # If we're using a direct URL pattern (like /ai-generated/),
        # the category_slug might be None, so check the URL name
        if not self.category_slug and hasattr(self, 'request'):
            resolved_url = resolve(self.request.path_info)
            if resolved_url.url_name in url_name_mapping:
                self.category_slug = url_name_mapping[resolved_url.url_name]
        
        # Get the content for the category
        return get_ai_content_by_category(self.category_slug, limit=None)
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        
        # Add category information
        context['category_slug'] = self.category_slug
        context['category_name'] = get_category_display_name(self.category_slug)
        context['category_description'] = get_category_description(self.category_slug)
        
        # Add AI content counts for the sidebar
        context.update(get_ai_content_counts())
        
        return context


@login_required
def ai_movie_detail(request, movie_id):
    """View for displaying AI movie details."""
    # Get the movie with related data
    movie = get_object_or_404(
        Movie.objects.select_related('content_rating').prefetch_related(
            'genres',
            'cast',
            'directors',
            Prefetch('seasons', queryset=Season.objects.prefetch_related(
                Prefetch('episodes', queryset=Episode.objects.order_by('episode_number'))
            ).order_by('season_number'))
        ),
        id=movie_id,
        is_active=True
    )
    
    # Check if movie is in user's watchlist
    in_my_list = False
    if request.user.is_authenticated:
        in_my_list = MyList.objects.filter(user=request.user, movie=movie).exists()
    
    # Get user's rating if exists
    user_rating = None
    if request.user.is_authenticated:
        try:
            rating = Rating.objects.get(user=request.user, movie=movie)
            user_rating = rating.rating
        except Rating.DoesNotExist:
            pass
    
    # Get similar AI content
    similar_content = Movie.objects.filter(
        content_category=movie.content_category,
        is_active=True
    ).exclude(id=movie.id).order_by('?')[:6]
    
    # Check if content is a series
    is_series = hasattr(movie, 'seasons') and movie.seasons.exists()
    seasons = movie.seasons.all() if is_series else None
    
    context = {
        'movie': movie,
        'in_my_list': in_my_list,
        'user_rating': user_rating,
        'similar_content': similar_content,
        'is_series': is_series,
        'seasons': seasons,
    }
    
    return render(request, 'movies/movie_detail.html', context)
